#!/bin/bash

# ai-commands - Unified script for AI command workflow management
# Usage:
#   ai-commands setup [file]    - Add instructions to AGENTS.md (or specified file)
#   ai-commands get <name>      - Return full command prompt content
#   ai-commands list            - List all available commands
#   ai-commands remove [file]   - Remove instructions from AGENTS.md

set -e

# Determine dotfiles directory (resolve symlinks)
SCRIPT_PATH="${BASH_SOURCE[0]}"
# Resolve symlink if necessary
if [ -L "$SCRIPT_PATH" ]; then
    SCRIPT_PATH="$(readlink -f "$SCRIPT_PATH")"
fi
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
DOTFILES_DIR="$(dirname "$SCRIPT_DIR")"
COMMANDS_DIR="$DOTFILES_DIR/claude/commands"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Normalize command name (handle hyphens vs underscores)
normalize_command_name() {
    local name="$1"
    # Try exact match first
    if [ -f "$COMMANDS_DIR/${name}.md" ]; then
        echo "${name}.md"
        return 0
    fi

    # Try with underscores
    local underscore_name="${name//-/_}"
    if [ -f "$COMMANDS_DIR/${underscore_name}.md" ]; then
        echo "${underscore_name}.md"
        return 0
    fi

    # Try with hyphens
    local hyphen_name="${name//_/-}"
    if [ -f "$COMMANDS_DIR/${hyphen_name}.md" ]; then
        echo "${hyphen_name}.md"
        return 0
    fi

    return 1
}

# List all available commands
list_commands() {
    if [ ! -d "$COMMANDS_DIR" ]; then
        print_error "Commands directory not found: $COMMANDS_DIR"
        return 1
    fi

    print_info "Available AI commands:"
    echo ""

    for file in "$COMMANDS_DIR"/*.md; do
        if [ -f "$file" ]; then
            local basename=$(basename "$file" .md)
            local description=""

            # Try to extract description from YAML frontmatter
            if grep -q "^---$" "$file" 2>/dev/null; then
                description=$(sed -n '/^---$/,/^---$/p' "$file" | grep "^description:" | sed 's/^description: *//' || echo "")
            fi

            if [ -n "$description" ]; then
                echo "  ${basename} - ${description}"
            else
                echo "  ${basename}"
            fi
        fi
    done
    echo ""
    print_info "Usage: ai-commands get <command-name>"
}

# Get command content
get_command() {
    local command_name="$1"

    if [ -z "$command_name" ]; then
        print_error "Command name required"
        echo "Usage: ai-commands get <command-name>"
        return 1
    fi

    local file_name=$(normalize_command_name "$command_name")

    if [ $? -ne 0 ] || [ -z "$file_name" ]; then
        print_error "Command not found: $command_name"
        echo ""
        list_commands
        return 1
    fi

    local file_path="$COMMANDS_DIR/$file_name"

    # Output the full content of the command file
    cat "$file_path"
}

# Setup instructions in AGENTS.md
setup_instructions() {
    local target_file="${1:-AGENTS.md}"

    # Check if commands directory exists
    if [ ! -d "$COMMANDS_DIR" ]; then
        print_error "Commands directory not found: $COMMANDS_DIR"
        return 1
    fi

    # Create AGENTS.md if it doesn't exist
    if [ ! -f "$target_file" ]; then
        print_info "Creating new $target_file"
        echo "# AI Agent Instructions" > "$target_file"
        echo "" >> "$target_file"
    fi

    # Check if instructions already exist
    if grep -q "<!-- AI-COMMANDS:START -->" "$target_file" 2>/dev/null; then
        print_warning "AI command instructions already exist in $target_file"
        read -p "Replace existing instructions? (y/n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_info "Aborting."
            return 0
        fi
        remove_instructions "$target_file"
    fi

    # Generate list of available commands
    local commands_list=""
    for file in "$COMMANDS_DIR"/*.md; do
        if [ -f "$file" ]; then
            local basename=$(basename "$file" .md)
            local description=""

            # Extract description from YAML frontmatter
            if grep -q "^---$" "$file" 2>/dev/null; then
                description=$(sed -n '/^---$/,/^---$/p' "$file" | grep "^description:" | sed 's/^description: *//' || echo "")
            fi

            if [ -n "$description" ]; then
                commands_list="${commands_list}- \`${basename}\` - ${description}\n"
            else
                commands_list="${commands_list}- \`${basename}\`\n"
            fi
        fi
    done

    # Append instructions to target file
    cat >> "$target_file" << 'EOF'

<!-- AI-COMMANDS:START -->
## Custom AI Command Workflows

This project has access to reusable AI command workflows from your dotfiles.

### How to Execute Commands

When the user requests any of these workflows, use the Bash tool to retrieve the command instructions:

```bash
ai-commands get <command-name>
```

The command will output the complete workflow instructions. Read the output carefully and follow all instructions exactly as written.

### Available Commands

EOF

    # Add the commands list
    echo -e "$commands_list" >> "$target_file"

    cat >> "$target_file" << 'EOF'

### Usage Example

When user says "save the session" or "create a summary":
1. Run: `ai-commands get save-session`
2. Read the complete output
3. Follow all instructions in the returned content exactly

When user says "create a plan":
1. Run: `ai-commands get create-plan`
2. Follow the returned workflow instructions

### Command Location

All commands are stored in: `~/dotfiles/claude/commands/`

You can also run `ai-commands list` to see all available commands.

<!-- AI-COMMANDS:END -->
EOF

    print_success "AI command instructions added to $target_file"
    print_info "The following commands are now available:"
    echo -e "$commands_list"
}

# Remove instructions from file
remove_instructions() {
    local target_file="${1:-AGENTS.md}"

    if [ ! -f "$target_file" ]; then
        print_error "File not found: $target_file"
        return 1
    fi

    if ! grep -q "<!-- AI-COMMANDS:START -->" "$target_file"; then
        print_warning "No AI command instructions found in $target_file"
        return 0
    fi

    # Remove the section between markers
    sed -i.bak '/<!-- AI-COMMANDS:START -->/,/<!-- AI-COMMANDS:END -->/d' "$target_file"

    # Remove the backup file
    rm -f "${target_file}.bak"

    print_success "AI command instructions removed from $target_file"
}

# Show usage
show_usage() {
    cat << EOF
ai-commands - Unified AI command workflow management

Usage:
  ai-commands setup [file]      Add command instructions to AGENTS.md (or specified file)
  ai-commands get <name>        Return full command prompt content
  ai-commands list              List all available commands
  ai-commands remove [file]     Remove instructions from AGENTS.md (or specified file)
  ai-commands help              Show this help message

Examples:
  ai-commands setup                    # Add instructions to AGENTS.md in current directory
  ai-commands get save-session         # Output the save-session command prompt
  ai-commands list                     # List all available commands
  ai-commands remove                   # Remove instructions from AGENTS.md

Commands are stored in: $COMMANDS_DIR

EOF
}

# Main command router
main() {
    local subcommand="${1:-help}"

    case "$subcommand" in
        setup)
            shift
            setup_instructions "$@"
            ;;
        get)
            shift
            get_command "$@"
            ;;
        list|ls)
            list_commands
            ;;
        remove|rm)
            shift
            remove_instructions "$@"
            ;;
        help|--help|-h)
            show_usage
            ;;
        *)
            print_error "Unknown command: $subcommand"
            echo ""
            show_usage
            exit 1
            ;;
    esac
}

main "$@"
